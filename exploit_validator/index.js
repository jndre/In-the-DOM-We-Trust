const { MongoClient } = require("mongodb");
const { validate, validate_markup_injection_attribute, validate_markup_injection_tag } = require("./validator");
const { create_indices } = require("./prepare_db");
const assert = require("assert");
const host = process.env.MONGO_HOST || "mongo";
const port = process.env.MONGO_PORT || "27017";
const database_name = process.env.MONGO_DATABASE || "finding-database";
const collectionName = process.env.EXPLOITS_COLLECTION || "findings-exploits";
const validation_collection_name = process.env.VALIDATION_FLOWS_COLLECTION || "exploit_validation";
var mongoDbUrl = "mongodb://" + host + ":" + port + "/" + database_name;

const client = new MongoClient(mongoDbUrl, { useNewUrlParser: true, useUnifiedTopology: true });


function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function trimString(string, length) {
  return string.length > length ?
    string.substring(0, length) + '...' :
    string;
};

async function validate_internal(exploit, cookies, browser) {
  var result = {
    "url" : exploit.url,
    "success": false,
    "settings": exploit.settings,
    "method": exploit.method,
    "status": "validated",
    success_bypass_csp: false,
    context_bypass_csp: "",
    content_bypass_csp: "",
    error_bypass_csp: "",
    csp_bypass_csp: "",
    csp_report_only_bypass_csp: "",
    csp_meta_bypass_csp: "",
    csp_meta_errors_bypass_csp: "",
    success_with_csp: false,
    context_with_csp: "",
    content_with_csp: "",
    error_with_csp: "",
    csp_with_csp: "",
    csp_report_only_with_csp: "",
    csp_meta_with_csp: "",
    csp_meta_errors_with_csp: "",
    "flows": []
  };
  try {
    if(exploit.method === 'N') {
      result = await validate_markup_injection_tag(exploit, browser);
    } else if (exploit.method === 'M') {
      result = await validate_markup_injection_attribute(exploit, browser);

    } else {
      result = await validate(exploit, cookies, browser);
    }
  } catch(err) {
    // Catching anything we might have missed
    console.log("Uncaught error: ", err);
    result.success = false;
    result.status = "error";
  }
  return result;
}

async function validate_finding(col, val_col, browser) {

  var doc = await col.findOneAndUpdate(
    { "exploits.status": "generated" },
    {$set:{"exploits.$.status":"in_validation"}},
    {returnOriginal:true, projection: {_id: 1, domain: 1, cookies: 1, "loc": 1, "exploits.$": 1}});
  if(doc === null || doc.value === null) {
    return false;
  }
  // var full_out = JSON.stringify(doc);
  // console.log("full doc:", full_out);
  var finding = doc.value;
  // console.log("Working on", finding._id, " loc: ", trimString(finding.loc, 30));
  assert.equal(1, finding.exploits.length);
  var exploit = finding.exploits[0];
  assert("in_validation", exploit.status);
  // var out = JSON.stringify(exploit);

  //console.log("Trying to exploit:", out);
  // Set some default values:

  let result = await validate_internal(exploit, [], browser);
  let retried = false;
  if(result.status === "error") {
    result =  await validate_internal(exploit, [], browser);
    retried = true;
  }
  //console.log(JSON.stringify(result, null, 2));


  console.log(`Validation result for method '${exploit.method}' on ${finding.domain}: ${result.status}, success: ${result.success}, retried: ${retried}`);
  try {
    await val_col.insertOne({
        exploit_uuid: exploit.uuid,
        method: exploit.method,
        success: result.success,
        flows: result.flows,
        success_bypass_csp: result.success_bypass_csp,
        context_bypass_csp: result.context_bypass_csp,
        content_bypass_csp: result.content_bypass_csp,
        error_bypass_csp: result.error_bypass_csp,
        csp_bypass_csp: result.csp_bypass_csp,
        csp_report_only_bypass_csp: result.csp_report_only_bypass_csp,
        csp_meta_bypass_csp: result.csp_meta_bypass_csp,
        csp_meta_errors_bypass_csp: result.csp_meta_errors_bypass_csp,
        success_with_csp: result.success_with_csp,
        context_with_csp: result.context_with_csp,
        content_with_csp: result.content_with_csp,
        error_with_csp: result.error_with_csp,
        csp_with_csp: result.csp_with_csp,
        csp_report_only_with_csp: result.csp_report_only_with_csp,
        csp_meta_with_csp: result.csp_meta_with_csp,
        csp_meta_errors_with_csp: result.csp_meta_errors_with_csp,
    });
  } catch(err) {
    console.log("Uncaught error: ", err);
  }

  var validated = await col.findOneAndUpdate(
    { _id: finding._id, "exploits.status": "in_validation", "exploits.url": exploit.url, "exploits.method": exploit.method },
    {$set:{
      "exploits.$.status": result.status,
      "exploits.$.success": result.success,
      "exploits.$.success_bypass_csp": result.success_bypass_csp,
      "exploits.$.context_bypass_csp": result.context_bypass_csp,
      "exploits.$.content_bypass_csp": result.content_bypass_csp,
      "exploits.$.error_bypass_csp": result.error_bypass_csp,
      "exploits.$.csp_bypass_csp": result.csp_bypass_csp,
      "exploits.$.csp_report_only_bypass_csp": result.csp_report_only_bypass_csp,
      "exploits.$.csp_meta_bypass_csp": result.csp_meta_bypass_csp,
      "exploits.$.csp_meta_errors_bypass_csp": result.csp_meta_errors_bypass_csp,
      "exploits.$.success_with_csp": result.success_with_csp,
      "exploits.$.context_with_csp": result.context_with_csp,
      "exploits.$.content_with_csp": result.content_with_csp,
      "exploits.$.error_with_csp": result.error_with_csp,
      "exploits.$.csp_with_csp": result.csp_with_csp,
      "exploits.$.csp_report_only_with_csp": result.csp_report_only_with_csp,
      "exploits.$.csp_meta_with_csp": result.csp_meta_with_csp,
      "exploits.$.csp_meta_errors_with_csp": result.csp_meta_errors_with_csp,
    }},
    {returnOriginal:true, projection: {_id: 1, "loc": 1, "exploits.$": 1}});
  assert.notEqual(null, validated);
  // var val_out = JSON.stringify(validated);
  //console.log("Wrote back into:", val_out);
  return true;
}
const argv = require("minimist")(process.argv.slice(2));
const browser = argv["browser"] === undefined ? "foxhound" : argv["browser"];

client.connect().then(async function() {
  const db = client.db(database_name);
  const col = db.collection(collectionName);
  const val_col = db.collection(validation_collection_name);
  await create_indices(col);
  var cont = true;
  var count = -1;
  var slept = 0;
  while(slept < 20) {
    cont = await validate_finding(col, val_col, browser);
    if(!cont) {
      await sleep(180000);
      console.log("sleepy..");
      slept++;
      continue;
    }
    count++;
  }
  console.log("Validated", count, "exploits!");
  await client.close();
});


