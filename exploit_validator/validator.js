const { firefox } = require("playwright");
const common = require("./common.js");

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

const markupInjScript = common.readFile("markup.js");
const flowHandler = common.readFile("flowHandler.js");
const Firefox_User_Prefereces = {
      "media.autoplay.default": 5,
      "media.autoplay.allow-extension-background-pages": false,
      "media.autoplay.block-event.enabled": true,
      "media.autoplay.enabled.user-gestures-needed": false,
      "dom.always_stop_slow_scripts": true,
      "dom.use_watchdog": true,
      "dom.max_script_run_time": 30,
      "dom.max_chrome_script_run_time": 60,
      "dom.max_ext_content_script_run_time": 15,
      "browser.cache.disk.enable": false,
      "browser.cache.memory.enable": false,
      "privacy.trackingprotection.enabled": false,
      "privacy.trackingprotection.fingerprinting.enabled": false,
      "privacy.trackingprotection.origin_telemetry.enabled": false,
      "privacy.trackingprotection.socialtracking.enabled": false,
      "privacy.trackingprotection.pbmode.enabled": false,
      "privacy.socialtracking.block_cookies.enabled": false,
      "network.cookie.cookieBehavior": 0,
      "security.fileuri.strict_origin_policy": false,
      "browser.download.folderList": 2,
      "pdfjs.disabled": true ,
      "browser.download.manager.showWhenStarting": false,
      "browser.download.dir": "/tmp",
      "browser.helperApps.neverAsk.saveToDisk": "text/csv,application/x-msexcel,application/excel,application/x-excel,application/vnd.ms-excel,image/png,image/jpeg,text/html,text/plain,application/msword,application/xml,application/pdf,application/zip",
      "browser.helperApps.alwaysAsk.force": false,
      "browser.download.manager.alertOnEXEOpen": false,
      "browser.download.manager.focusWhenStarting": false,
      "browser.download.manager.useWindow": false,
      "browser.download.manager.showAlertOnComplete": false,
      "browser.download.manager.closeWhenDone": false,
      // Causes crashes
      "gfx.x11-egl.force-disabled": true,
      "webgl.disabled": true
      // .setPreference("browser.privatebrowsing.autostart", true)
    };

async function validate(exploit, cookies, browser) {
  // console.log(JSON.stringify(exploit, null, 2));
  let ff_path = process.env.FOXHOUND_PATH;
  if(ff_path === undefined) {
    console.error("Env variable FOXHOUND_PATH needs to be set");
    process.exit(1);
  }
  const ff_config = {
    executablePath: ff_path,
    firefoxUserPrefs: Firefox_User_Prefereces
  };

  var result = {
    url : exploit.url,
    success: false,
    success_bypass_csp: false,
    context_bypass_csp: "",
    content_bypass_csp: "",
    error_bypass_csp: "",
    success_with_csp: false,
    context_with_csp: "",
    content_with_csp: "",
    error_with_csp: "",
    settings: exploit.settings,
    method: exploit.method,
    status: "validated",
    uuid: exploit.uuid,
    flows: []
  };

  let res_csp = null;
  let res_nocsp = null;
  try {
    try {
      res_csp = await validate_xss(ff_config, exploit, true, cookies);
    } catch(e) {
      res_csp = await validate_xss(ff_config, exploit, true, cookies);
    }
    result.success_bypass_csp = res_csp.success;
    result.error_bypass_csp = res_csp.error;

    try {
      res_nocsp = await validate_xss(ff_config, exploit, false, cookies);
    } catch(e) {
      res_nocsp = await validate_xss(ff_config, exploit, false, cookies);
    }
    result.success_with_csp = res_nocsp.success;
    result.error_with_csp = res_nocsp.error;

    result.success = result.success_bypass_csp || result.success_with_csp;
  } catch (err) {
    // console.log(err);
    result.success = false;
    result.status = "error";
  } finally {
    return result;
  }
}
async function validate_xss(ff_config, exploit, bypassCSP, cookies) {
  // console.log(JSON.stringify(exploit, null, 2));
  let browser = await firefox.launch(Object.assign(ff_config, {}));
  let output = "";
  let message = exploit.uuid.replace(/-/g,"");
  var result = {
    url : exploit.url,
    success: false,
    settings: exploit.settings,
    method: exploit.method,
    status: "validated",
    uuid: exploit.uuid,
    flows: [],
    csp: "",
    cspReportOnly: "",
    cspMeta: "",
    cspMetaErrors: ""

  };
  try {
    let context = await browser.newContext({
      ignoreHTTPSErrors: true,
      bypassCSP: bypassCSP
    });
    await context.addInitScript(flowHandler);
    await context.addInitScript(markupInjScript);
    context.exposeBinding("__validator_taint_report", async function (source, value) {
        // console.log(value);
        // console.log(`${JSON.stringify(source, null, 2)} - ${JSON.stringify(value, null, 2)} `);
        result.flows.push(value);
    });

    // await context.addCookies(cookies);
    // if(cookies.length > 0) {
    //   console.log(`Added cookies: ${JSON.stringify(cookies, null, 2)}`);
    // }

    context.exposeBinding("taintfoxLog", (params, msg) => {
      console.log(`TF log called: ${msg}`);
      output = String(msg);
    });
    const page = await context.newPage();

    let response = await page.goto(exploit.url, {
      referrer: "http://your-domain.com?thisisacrawler",
      timeout: 30000,
      waitUntil: "load"
    });

    await sleep(10000);
    const csp = await response.headerValue("Content-Security-Policy");
    const csp_report_only = await response.headerValue("Content-Security-Policy-Report-Only");

    meta_csp = await page.evaluate("getCSPMetaTags()");
    result.cspMeta = meta_csp.csp;
    result.cspMetaErrors = meta_csp.errors;
    if(csp != null) {
      result.csp = csp;
    }
    if(csp_report_only != null) {
      result.cspReportOnly = csp_report_only;
    }
    if(output.indexOf(message) >= 0) {
      // console.log("Successfully validated!");
      result.success = true;
    }
    await page.close();
    return result;
  } catch (err) {
    if(output.indexOf(message) >= 0) {
      console.log("Successfully validated despite errors: " + err);
      result.success = true;
      return result;
    }
    result.success = false;
    result.status = "error";
    result.error = err.toString();
    return result;
  } finally {
    await browser.close();
  }
}

async function validateAttack(ff_config, exploit, bypassCSP, evalFunc) {
  let res = {
    "exists": false,
    "context": "",
    "content": "",
    "error": null,
    csp: "",
    cspReportOnly: "",
    cspMeta: "",
    cspMetaErrors: ""
  };
  let browser = await firefox.launch(Object.assign(ff_config, {}));

  try {
    let context = await browser.newContext({
      ignoreHTTPSErrors: true,
      bypassCSP: bypassCSP
    });

    await context.addInitScript(markupInjScript);

    const page = await context.newPage();
    let response = await page.goto(exploit.url, {
      referrer: "http://your-domain.com?thisisacrawler",
      timeout: 30000,
      waitUntil: "load"
    });
    await sleep(10000);
    const csp = await response.headerValue("Content-Security-Policy");
    const csp_report_only = await response.headerValue("Content-Security-Policy-Report-Only");

    meta_csp = await page.evaluate("getCSPMetaTags()");
    res = await page.evaluate(evalFunc);
    res.cspMeta = meta_csp.csp;
    res.cspMetaErrors = meta_csp.errors;
    if(csp != null) {
      res.csp = csp;
    }
    if(csp_report_only != null) {
      res.cspReportOnly = csp_report_only;
    }
    // console.log(`${JSON.stringify(res, null, 2)}`);

    await page.close();
  } catch(err) {
    console.error(err);
  } finally {
    await browser.close();
    return res;
  }

}

async function validate_markup_injection_tag(exploit) {
  if(exploit.method != 'N') {
    console.error(`Exploit with id ${exploit.uuid} and method '${exploit.method}' wrongfully dispatched for method 'M' (tag attack) handler`);
    process.exit(1);
  }
  return await validate_markup_injection(exploit, 'evaluateTagAttack()');
}

async function validate_markup_injection_attribute(exploit) {
  if(exploit.method != 'M') {
    console.error(`Exploit with id ${exploit.uuid} and method '${exploit.method}' wrongfully dispatched for method 'N' (attribute attack) handler`);
    process.exit(1);
  }
  return await validate_markup_injection(exploit, 'evaluateAttributeAttack()');
}

async function validate_markup_injection(exploit, evalFunc) {
  // console.log(JSON.stringify(exploit, null, 2));
  let ff_path = process.env.FOXHOUND_PATH;
  if(ff_path === undefined) {
    console.error("Env variable FOXHOUND_PATH needs to be set");
    process.exit(1);
  }
  const ff_config = {
    executablePath: ff_path,
    firefoxUserPrefs: Firefox_User_Prefereces
  };

  var result = {
    url : exploit.url,
    success: false,
    success_bypass_csp: false,
    context_bypass_csp: "",
    content_bypass_csp: "",
    error_bypass_csp: "",
    csp_bypass_csp: "",
    csp_report_only_bypass_csp: "",
    csp_meta_bypass_csp: "",
    csp_meta_errors_bypass_csp: "",
    success_with_csp: false,
    context_with_csp: "",
    content_with_csp: "",
    error_with_csp: "",
    csp_with_csp: "",
    csp_report_only_with_csp: "",
    csp_meta_with_csp: "",
    csp_meta_errors_with_csp: "",
    settings: exploit.settings,
    method: exploit.method,
    status: "validated",
    uuid: exploit.uuid,
    flows: []
  };

  let res_csp = null;
  let res_nocsp = null;
  try {
    try {
      res_csp = await validateAttack(ff_config, exploit, true, evalFunc);
    } catch(e) {
      res_csp = await validateAttack(ff_config, exploit, true, evalFunc);
    }
    // console.log(JSON.stringify(res_csp,null,2));
    result.success_bypass_csp = res_csp.exists;
    result.context_bypass_csp = res_csp.context;
    result.content_bypass_csp = res_csp.content;
    result.error_bypass_csp = res_csp.error;
    result.csp_bypass_csp = res_csp.csp;
    result.csp_report_only_bypass_csp = res_csp.cspReportOnly;
    result.csp_meta_bypass_csp = res_csp.cspMeta;
    result.csp_meta_errors_bypass_csp = res_csp.cspMetaErrors;

    try {
      res_nocsp = await validateAttack(ff_config, exploit, false, evalFunc);
    } catch(e) {
      res_nocsp = await validateAttack(ff_config, exploit, false, evalFunc);
    }
    // console.log(JSON.stringify(res_nocsp,null,2));
    result.success_with_csp = res_nocsp.exists;
    result.context_with_csp = res_nocsp.context;
    result.content_with_csp = res_nocsp.content;
    result.error_with_csp = res_nocsp.error;
    result.csp_with_csp = res_nocsp.csp;
    result.csp_report_only_with_csp = res_nocsp.cspReportOnly;
    result.csp_meta_with_csp = res_nocsp.cspMeta;
    result.csp_meta_errors_with_csp = res_nocsp.cspMetaErrors;

    result.success = result.success_bypass_csp || result.success_with_csp;
    // console.log(JSON.stringify(result, null, 2));
  } catch (err) {
    // console.log(err);
    result.success = false;
    result.status = "error";
  } finally {
    return result;
  }
}

exports.validate = validate;
exports.validate_markup_injection_tag = validate_markup_injection_tag;
exports.validate_markup_injection_attribute = validate_markup_injection_attribute;
