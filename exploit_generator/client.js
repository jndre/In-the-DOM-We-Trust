const { MongoClient } = require('mongodb');
const { create_indices } = require("./prepare_db");
const crypto = require("crypto");
const host = process.env.EXPLOIT_EXPORT_MONGO_HOST || "mongo";
const port = process.env.EXPLOIT_EXPORT_MONGO_PORT || "27017";
const database_name = process.env.EXPLOIT_EXPORT_MONGO_DATABASE || "finding-database";
var mongoDbUrl = "mongodb://" + host + ":" + port + "/" + database_name;

var nExploits = 0;
var nExploitsA = 0;
var nExploitsB = 0;
var nExploitsC = 0;
var nExploitsD = 0;
var nExploitsE = 0;
var nExploitsF = 0;
var nExploitsG = 0;
var nExploitsH = 0;
var nExploitsI = 0;
var nExploitsJ = 0;
var nExploitsK = 0;
var nExploitsM = 0;
var nExploitsN = 0;
var nFindings = 0;

var regenerate = process.env.REGENERATE == "TRUE";
var collectionName = process.env.FINDINGS_COLLECTION || "findings";
var exploitsName = process.env.EXPLOITS_COLLECTION || "findings-exploits";

const conversion = require('./utils/generator/conversion')
const exploitGen = require('./utils/generator/exploit-generator')
const client = new MongoClient(mongoDbUrl, { useNewUrlParser: true, useUnifiedTopology: true });

process.on('unhandledRejection', up => { throw up });

function trimString(string, length) {
  return string.length > length ?
    string.substring(0, length) + '...' :
    string;
};

function hash(obj) {
    //Convert the object to a string
    let str = typeof obj == "string" ? obj : JSON.stringify(obj);
    //Generates a 64-bit hash represented by 11 characters (88 bit)
    //This string representation is not the most efficient, but better to work with than large integers or binary buffers
    let result = crypto.createHash("md5").update(str).digest().toString("base64", 0, 8).substring(0, 11);
    //Sanitize for filenames (as recommended in RFC 3548)
    result = result.replace(/\//g, "_");
    result = result.replace(/\+/g, "-");
    return result;
};

function exploit_hash(exploit) {
  let payload = exploit.uuid.replace(/-/g,"");
  let base_url = exploit.url.replace(payload, "");
  return hash(base_url);
}

const sleep = (waitTimeInMs) => new Promise(resolve => setTimeout(resolve, waitTimeInMs));

console.log("Exploit Generator starting with regenerate:", regenerate);

client.connect({ socketTimeoutMS: 3600000 })
  .then(async client => {

  const col = client.db().collection(collectionName);
  const colExploits = client.db().collection(exploitsName);
  console.log("Creating indices");
  await create_indices(col);
  await create_indices(colExploits);

  if (regenerate) {
    console.log("Removing existing exploits");
    await col.updateMany({exploits: { $exists: true }}, { $unset: { 'exploits': "" } });
    console.log("Done!");
  } else {
    while (true) {

      var nTotal = await col.estimatedDocumentCount();
      console.log("Found", nTotal, "findings");

      var cursor = undefined;

      cursor = col.find({ exploits: { $exists: false } })
        .addCursorFlag('noCursorTimeout', true);

      try {
        while (await cursor.hasNext()) {
          var finding = await cursor.next();
          if (finding) {
            nFindings += 1;
            let sources = Array.from(new Set(finding.sources));
            let sink = finding.sink;
            const converted = conversion.getFinding(finding);
            var exploits = exploitGen.generateExploits(converted);
            if (exploits) {
              nExploitsA += exploits.methodA.length;
              nExploitsB +=exploits.methodB.length;
              nExploitsC += exploits.methodC.length;
              nExploitsD += exploits.methodD.length;
              nExploitsE += exploits.methodE.length;
              nExploitsF += exploits.methodF.length;
              nExploitsG += exploits.methodG.length;
              nExploitsH += exploits.methodH.length;
              nExploitsI += exploits.methodI.length;
              nExploitsJ += exploits.methodJ.length;
              nExploitsK += exploits.methodK.length;
              nExploitsM += exploits.methodM.length;
              nExploitsN += exploits.methodN.length;
              nExploits = nExploitsA + nExploitsB + nExploitsC + nExploitsD + nExploitsE  + nExploitsF + nExploitsG + nExploitsH + nExploitsI + nExploitsJ + nExploitsK + nExploitsM + nExploitsN;

              if (exploits.methodA.length + exploits.methodB.length + exploits.methodC.length + exploits.methodD.length  + exploits.methodE.length + exploits.methodF.length + exploits.methodG.length + exploits.methodH.length + exploits.methodI.length + exploits.methodJ.length + exploits.methodK.length + exploits.methodM.length + exploits.methodN.length!== 0) {
                console.log("------------------------------------------------------------");
                console.log(finding.loc, ":", sources, "-->", sink);
                console.log("-> Generated Links: ", trimString(JSON.stringify(exploits), 80));
                console.log("Generated: Exploits A:", exploits.methodA.length, "Exploits B:", exploits.methodB.length, "Exploits C:", exploits.methodC.length, "Exploits D:", exploits.methodD.length, "Exploits E:", exploits.methodE.length, "Exploits F:", exploits.methodF.length, "Exploits G:", exploits.methodG.length, "Exploits H:", exploits.methodH.length, "Exploits I:", exploits.methodI.length, "Exploits J:", exploits.methodJ.length, "Exploits K:", exploits.methodK.length, "Exploits M:", exploits.methodM.length, "Exploits N:", exploits.methodN.length);
                console.log("Totals:", nFindings, "/", nTotal, "Exploits A:", nExploitsA, "Exploits B:", nExploitsB, "Exploits C:", nExploitsC, "Exploits D:", nExploitsD, "Exploits E:", nExploitsE, "Exploits F:", nExploitsF, "Exploits G:", nExploitsG, "Exploits H:", nExploitsH, "Exploits I:", nExploitsI, "Exploits J:", nExploitsJ, "Exploits K:", nExploitsK, "Exploits M:", nExploitsM, "Exploits N:", nExploitsN, "Exploits total:", nExploits);
                console.log("------------------------------------------------------------");
              }

              var results = [];
             exploits.methodA.forEach(e => {
               results.push({
                 uuid: e.uuid,
                 url: e.url,
                 success: undefined,
                 status: "generated",
                 settings: e.settings,
                 method: "A"
               });
             });
             exploits.methodB.forEach(e => {
               results.push({
                 uuid: e.uuid,
                 url: e.url,
                 success: undefined,
                 status: "generated",
                 settings: e.settings,
                 method: "B"
               });
             });
                exploits.methodC.forEach(e => {
                  let hash = exploit_hash(e);
                results.push({
                  uuid: e.uuid,
                  url: e.url,
                  hash: hash,
                  success: undefined,
                  status: "generated",
                  settings: e.settings,
                  method: "C"
                });
              });
              // exploits.methodD.forEach(e => {
              //     let hash = exploit_hash(e);
              //   results.push({
              //     uuid: e.uuid,
              //     url: e.url,
              //     hash: hash,
              //     success: undefined,
              //     status: "generated",
              //     settings: e.settings,
              //     method: "D"
              //   });
              // });
              // exploits.methodE.forEach(e => {
              //     let hash = exploit_hash(e);
              //   results.push({
              //     uuid: e.uuid,
              //     url: e.url,
              //     hash: hash,
              //     success: undefined,
              //     status: "generated",
              //     settings: e.settings,
              //     method: "E"
              //   });
              // });
              // exploits.methodF.forEach(e => {
              //     let hash = exploit_hash(e);
              //   results.push({
              //     uuid: e.uuid,
              //     url: e.url,
              //     hash: hash,
              //     success: undefined,
              //     status: "generated",
              //     settings: e.settings,
              //     method: "F"
              //   });
              // });
              // exploits.methodG.forEach(e => {
              //     let hash = exploit_hash(e);
              //   results.push({
              //     uuid: e.uuid,
              //     url: e.url,
              //     hash: hash,
              //     success: undefined,
              //     status: "generated",
              //     settings: e.settings,
              //     method: "G"
              //   });
              // });
              // exploits.methodH.forEach(e => {
              //     let hash = exploit_hash(e);
              //   results.push({
              //     uuid: e.uuid,
              //     url: e.url,
              //     hash: hash,
              //     success: undefined,
              //     status: "generated",
              //     settings: e.settings,
              //     method: "H"
              //   });
              // });
              // exploits.methodI.forEach(e => {
              //     let hash = exploit_hash(e);
              //   results.push({
              //     uuid: e.uuid,
              //     url: e.url,
              //     hash: hash,
              //     success: undefined,
              //     status: "generated",
              //     settings: e.settings,
              //     method: "I"
              //   });
              // });
              // exploits.methodJ.forEach(e => {
              //     let hash = exploit_hash(e);
              //   results.push({
              //     uuid: e.uuid,
              //     url: e.url,
              //     hash: hash,
              //     success: undefined,
              //     status: "generated",
              //     settings: e.settings,
              //     method: "J"
              //   });
              // });
              // exploits.methodK.forEach(e => {
              //     let hash = exploit_hash(e);
              //   results.push({
              //     uuid: e.uuid,
              //     url: e.url,
              //     hash: hash,
              //     success: undefined,
              //     status: "generated",
              //     settings: e.settings,
              //     method: "K"
              //   });
              // });
              exploits.methodM.forEach(e => {
                  let hash = exploit_hash(e);
                results.push({
                  uuid: e.uuid,
                  url: e.url,
                  hash: hash,
                  success: undefined,
                  status: "generated",
                  settings: e.settings,
                  method: "M"
                });
              });
              exploits.methodN.forEach(e => {
                  let hash = exploit_hash(e);
                results.push({
                  uuid: e.uuid,
                  url: e.url,
                  hash: hash,
                  success: undefined,
                  status: "generated",
                  settings: e.settings,
                  method: "N"
                });
              });

              finding.exploits = results;

              col.updateOne({ _id : finding._id },
                            { $set: { 'exploits':results }})
                .then((obj) => {
                  //                console.log("Updated database object:", obj.result);
                });

              if (results.length > 0) {
                colExploits.updateOne({ _id : finding._id },
                                      { $set: finding },
                                      { upsert: true })
                  .then(async obj => {
                    console.log("Updated exploits collection");
                    var nTotal = await colExploits.estimatedDocumentCount();
                    console.log("Total:", nTotal, "findings with exploits");
                  });
              }

            }
          }
        }
      } catch (error) {
        console.error(error);
      } finally {
        cursor.close();
      }
      console.log("Waiting before querying DB");
      await sleep(10000);
    }
  }
});


