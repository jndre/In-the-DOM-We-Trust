(function (global) {
  "use strict";

  // Private modules
  var payloadGen = require("./payload-generator.js");
  var urlGen = require("./url-generator.js");
  var parser = require("./exploit-generator-js-parser.js");
  var breakGen = require("./exploit-generator-js-break.js");

  function generateExploit(finding, taint) {
    var exploits = {
      methodA: [],
      methodB: [],
      methodC: [],
      methodD: [],
      methodE: [],
      methodF: [],
      methodG: [],
      methodH: [],
      methodI: [],
      methodJ: [],
      methodK: [],
      methodM: [],
      methodN: [],
    };
    taint.replaceSettings.forEach((setting) => {
      var breakSequences, payload, sequence;

      setting.context = {
        type: "js",
        token: "",
        content: "",
      };

      breakSequences = generateBreakSequences(finding, taint, setting);
      if (!breakSequences) breakSequences = breakGen.getDefaultBreak();

      setting.inBreak = breakSequences.inBreak;
      setting.outBreak = breakSequences.outBreak;

      var comingExploits = urlGen.generateUrl(finding, taint, setting);
      if (exploits.methodA.length === 0) {
        comingExploits.methodA.forEach((exploit) => {
          if (exploit.url !== null)
            exploits.methodA = exploits.methodA.concat(comingExploits.methodA);
        });
      }
      comingExploits.methodB.forEach((exploit) => {
        if (exploit.url !== null)
          exploits.methodB = exploits.methodB.concat(comingExploits.methodB);
      });
      comingExploits.methodC.forEach((exploit) => {
        if (exploit.url !== null)
          exploits.methodC = exploits.methodC.concat(comingExploits.methodC);
      });
      comingExploits.methodD.forEach((exploit) => {
        if (exploit.url !== null)
          exploits.methodD = exploits.methodD.concat(comingExploits.methodD);
      });
      comingExploits.methodE.forEach((exploit) => {
        if (exploit.url !== null)
          exploits.methodE = exploits.methodE.concat(comingExploits.methodE);
      });
      comingExploits.methodF.forEach((exploit) => {
        if (exploit.url !== null)
          exploits.methodF = exploits.methodF.concat(comingExploits.methodF);
      });
      comingExploits.methodG.forEach((exploit) => {
        if (exploit.url !== null)
          exploits.methodG = exploits.methodG.concat(comingExploits.methodG);
      });
      comingExploits.methodH.forEach((exploit) => {
        if (exploit.url !== null)
          exploits.methodH = exploits.methodH.concat(comingExploits.methodH);
      });
      comingExploits.methodI.forEach((exploit) => {
        if (exploit.url !== null)
          exploits.methodI = exploits.methodI.concat(comingExploits.methodI);
      });
      comingExploits.methodJ.forEach((exploit) => {
        if (exploit.url !== null)
          exploits.methodJ = exploits.methodJ.concat(comingExploits.methodJ);
      });
      comingExploits.methodK.forEach((exploit) => {
        if (exploit.url !== null)
          exploits.methodK = exploits.methodK.concat(comingExploits.methodK);
      });
      comingExploits.methodM.forEach((exploit) => {
        if (exploit.url !== null)
          exploits.methodM = exploits.methodM.concat(comingExploits.methodM);
      });
      comingExploits.methodN.forEach((exploit) => {
        if (exploit.url !== null)
          exploits.methodN = exploits.methodN.concat(comingExploits.methodN);
      });
    });
    return exploits;
  }

  function buildSequence(setting, breakOutSequence, payload, breakInSequence) {
    if (setting.replaceBeginURL === setting.replaceEndURL) {
      return "#" + breakOutSequence + payload + breakInSequence;
    } else {
      return breakOutSequence + payload + breakInSequence;
    }
  }

  function generateBreakSequences(finding, taint, setting) {
    console.log("-> Generating break sequences");
    var taintedNodes = parser.getTaintedNodes(finding, taint);
    var regex = parser.getRegex(finding, taint);
    if (!taintedNodes) return;
    try {
      return breakGen.getBestBreakSequences(
        finding,
        taintedNodes,
        taint,
        setting,
        regex
      );
    } catch (err) {
      return;
    }
  }

  global.generateExploit = generateExploit;
})(exports);
