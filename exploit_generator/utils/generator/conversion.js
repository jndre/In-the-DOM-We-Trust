// Get findings from different formats e.g. Tainfox, Node or Chrome
(function (global) {
  var analyzer = require("./analyzer.js");
  var hybridOps = ["JSON.parse"];

  function getFinding(randomFinding) {
    var finding = null;
    if (randomFinding.taint) {
      finding = getFindingFromTainfox(randomFinding);
      analyzer.enhanceTaintInfo(finding);
    }
    return finding;
  }

  // --- Get flows from Tainfox format ---

  function getMetaFromTainfox(taintfoxFinding) {
    return { id: taintfoxFinding.id, tabId: taintfoxFinding.tabId };
  }

  function getTaintFromTainfox(taintPart) {
    var source = taintPart.flow[taintPart.flow.length - 1];
    return {
      begin: taintPart.begin,
      end: taintPart.end,
      func: source.operation,
      param: source.arguments[0] || "",
      operators: taintPart.flow,
    };
  }

  function getFindingFromTainfox(taintfoxFinding) {
    var decodedURI = taintfoxFinding.loc;
    try {
      decodedURI = decodeURIComponent(decodedURI);
    } catch (err) {
      console.log("Error while decoding url: ", err);
    } finally {
      var finding = {
        // decoding URL to find encoded tainted parts in URL
        location: decodedURI,
        sink: taintfoxFinding.sink,
        param: taintfoxFinding.str,
        taint: [],
        meta: getMetaFromTainfox(taintfoxFinding),
        // hybrid means there is probably a Javascript context implied by some operation
        hybrid: false,
      };

      for (var taintId in taintfoxFinding.taint) {
        if (
          taintfoxFinding.taint[taintId].flow.filter((flow) => {
            return hybridOps.includes(flow.operation);
          }).length > 0
        ) {
          finding.hybrid = true;
        }
        finding.taint.push(getTaintFromTainfox(taintfoxFinding.taint[taintId]));
      }

      return finding;
    }
  }

  // --- Get flows from Node format ---

  function getFindingFromNode(nodeFinding) {}

  // --- Get flows from Chrome format ---

  function getFindingFromChrome(chromeFinding) {}

  function analyzeTaints(convertedFinding) {
    convertedFinding.taint.forEach(function (taint) {
      analyzer.addStrategy(convertedFinding, taint);
    });

    return convertedFinding;
  }

  global.getFinding = getFinding;
})(exports);
