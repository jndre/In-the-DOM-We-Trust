(function(global){
	"use strict";

	// Node modules
	var jsParser = require('esprima');

	var nodeStackLimit = 100;

	var nodes = {	"Program" : ["body"],
					"Function" : [],
					"EmptyStatement" : [],
					"BlockStatement" : ["body"],
					"ExpressionStatement": ["expression"],
					"IfStatement" : ["test", "consequent", "alternate"],
					"LabeledStatement" : ["body"],
					"BreakStatement" : ["label"],
					"ContinueStatement" : ["label"],
					"WithStatement" : ["object", "body"],
					"SwitchStatement" : ["discriminant", "cases"],
					"ReturnStatement" : ["argument"],
					"ThrowStatement" : ["argument"],
					"TryStatement" : ["block", "handler", "guardedHandlers", "finalizer"],
					"WhileStatement" : ["test", "body"],
					"DoWhileStatement" : ["body", "test"],
					"ForStatement" : ["init", "test", "update", "body"],
					"ForInStatement" : ["left", "right", "body"],
					"ForOfStatement" : ["left", "right", "body"],
					"LetStatement" : ["head", "body"],
					"DebuggerStatement" : [],
					"FunctionDeclaration" : ["id", "params", "defaults", "rest", "body"],
					"VariableDeclaration" : ["declarations"],
					"VariableDeclarator" : ["id", "init"],
					"ThisExpression" : [],
					"ArrayExpression" : ["elements"],
					"ObjectExpression" : ["properties"],
					"Property" : ["key", "value"],
					"FunctionExpression" : ["id", "params", "defaults", "rest", "body"],
					"ArrowExpression" : ["params", "defaults", "rest", "body"],
					"SequenceExpression" : ["expressions"],
					"UnaryExpression" : ["argument"],
					"BinaryExpression" : ["left", "right"],
					"AssignmentExpression" : ["left", "right"],
					"UpdateExpression" : ["argument"],
					"LogicalExpression" : ["left", "right"],
					"ConditionalExpression" : ["test", "alternate", "consequent"],
					"NewExpression" : ["callee", "arguments"],
					"CallExpression" : ["callee", "arguments"],
					"MemberExpression" : ["object", "property"],
					"YieldExpression" : ["argument"],
					"ComprehensionExpression" : ["body", "blocks", "filter"],
					"GeneratorExpression" : ["body", "blocks", "filter"],
					"GraphExpression" : ["expression"],
					"GraphIndexExpression" : [],
					"LetExpression" : ["head", "body"],
					"ObjectPattern" : ["properties"],
					"ArrayPattern" : ["elements"],
					"SwitchCase" : ["test", "consequent"],
					"CatchClause" : ["param", "guard", "body"],
					"ComprehensionBlock" : ["left", "right"],
					"ComprehensionIf" : ["test"],
					"Identifier" : [],
					"Literal" : [],
					"UnaryOperator" : [],
					"BinaryOperator" : [],
					"LogicalOperator" : [],
					"AssignmentOperator" : [],
					"UpdateOperator" : []
	};

	

	function getRegexStack(tree, taint) {
		var {nodeStack, regex} = getSubnodesForRegex(tree);
		for (var i = 0; i < nodeStack.length && nodeStack.length < nodeStackLimit * 1000; i++) {
			if (!beforeTaint(nodeStack[i], taint)) continue;
			var result = getSubnodesForRegex(nodeStack[i]);
			nodeStack = nodeStack.concat(result.nodeStack);
			regex = regex.concat(result.regex);

		}
		return regex;
	}

	function getSubnodesForRegex(node) {
		var nodeStack = [];
		var regex = []

		for (var i = 0; i < nodes[node.type].length; i++) {
			if (node[nodes[node.type][i]] !== undefined) {
				var subNode = node[nodes[node.type][i]];
				if (subNode !== null) {
					nodeStack = nodeStack.concat(node[nodes[node.type][i]]);
					if (subNode["regex"]) regex.push(subNode["value"])
					// subNode.forEach(sub => {
					// 	if (sub["regex"]) regex = regex.push(subnode["regex"]["pattern"])
					// })
				} 
			}

		}

		return {nodeStack, regex};
	}

	function getTaintedNodeStack(tree, taint) {
		var nodeStack = getSubnodes(tree);
		for (var i = 0; i < nodeStack.length && nodeStack.length < nodeStackLimit; i++) {
			if (!containsTaint(nodeStack[i], taint)) continue;
			nodeStack = nodeStack.concat(getSubnodes(nodeStack[i]));

		}
		return nodeStack;
	}

	function getSubnodes(node) {
		var subNodes = [];

		for (var i = 0; i < nodes[node.type].length; i++) {
			if (node[nodes[node.type][i]] !== undefined) {
				var subNode = node[nodes[node.type][i]];
				if (subNode !== null) subNodes = subNodes.concat(node[nodes[node.type][i]]);
			}
		}

		return subNodes;
	}

	function containsTaint(node, taint) {
		if (!node || !node.range) return false;
		return  node.range[0] < taint.end && node.range[1] >= taint.end || 
				node.range[0] < taint.begin && node.range[1] >= taint.begin ||
				node.range[1] < taint.end && node.range[0] >= taint.begin;

		// return 	taint.begin <= node.range[0] && taint.end > node.range[0] ||
		// 		taint.begin < node.range[1] && taint.end >= node.range[1];
	}

	function beforeTaint(node, taint) {
		if (!node || !node.range) return false;
		return node.range[0] < taint.begin;
	}

	function getTaintedNodes(finding, taint) {
		var parseTree;
		try {
			parseTree = jsParser.parse(finding.param, {range: true});
		} catch(err) {
			console.log("JS esrpima parser error");
			return [];
		}
		return getTaintedNodeStack(parseTree, taint);
	}

	function getRegex(finding, taint) {
		var parseTree;
		try {
			parseTree = jsParser.parse(finding.param, {range: true, comment: true});
		} catch(err) {
			console.log("JS esrpima parser error");
			return [];
		}
		return getRegexStack(parseTree, taint);
	}

	exports.getTaintedNodes = getTaintedNodes;
	exports.getRegex = getRegex;

})(exports);