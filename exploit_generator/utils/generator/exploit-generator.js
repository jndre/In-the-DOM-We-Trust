(function (global) {
  "use strict";

  var htmlExploitGen = require("./exploit-generator-html.js");
  var jsExploitGen = require("./exploit-generator-js.js");
  var hybridExploitGen = require("./exploit-generator-hybrid.js");

  function generateExploits(finding) {
    var exploits = {
      methodA: [],
      methodB: [],
      methodC: [],
      methodD: [],
      methodE: [],
      methodF: [],
      methodG: [],
      methodH: [],
      methodI: [],
      methodJ: [],
      methodK: [],
      methodM: [],
      methodN: [],
    };
    var generator;
    // finding.taint.forEach(function(taint) {
    //   if(taint.func === "input.value") {
    // 	generator = htmlExploitGen;
    //   }
    // })
    if (!generator) generator = getGenerator(finding);

    if (!generator) return exploits;

    finding.taint.forEach(function (taint) {
      try {
        if (isRelevantSource(taint.func)) {
          const comingExploits = generator.generateExploit(finding, taint);
          if (exploits.methodA.length === 0)
            exploits.methodA = exploits.methodA.concat(comingExploits.methodA);
          exploits.methodB = exploits.methodB.concat(comingExploits.methodB);
          exploits.methodC = exploits.methodC.concat(comingExploits.methodC);
          exploits.methodE = exploits.methodE.concat(comingExploits.methodE);
          exploits.methodD = exploits.methodD.concat(comingExploits.methodD);
          exploits.methodF = exploits.methodF.concat(comingExploits.methodF);
          exploits.methodG = exploits.methodG.concat(comingExploits.methodG);
          exploits.methodH = exploits.methodH.concat(comingExploits.methodH);
          exploits.methodI = exploits.methodI.concat(comingExploits.methodI);
          exploits.methodJ = exploits.methodJ.concat(comingExploits.methodJ);
          exploits.methodK = exploits.methodK.concat(comingExploits.methodK);
          exploits.methodM = exploits.methodM.concat(comingExploits.methodM);
          exploits.methodN = exploits.methodN.concat(comingExploits.methodN);
        }
      } catch (err) {
        console.log(
          "An error occured in generator.generateExploit. Finding location: ",
          finding.location
        );
        console.log("Error message: ", err.message);
        console.log(err);
      }
    });

    return removeDuplicates(exploits);
  }

  function getGenerator(finding) {
    /*if (finding.hybrid) {
      console.log(
        "Generating Hybrid exploits for " +
          finding.location.substring(0, 80) +
          "..."
      );
      return hybridExploitGen;
    } else*/ if (
      finding.sink === "document.write" ||
      finding.sink === "document.writeln" ||
      finding.sink === "innerHTML" ||
      finding.sink === "outerHTML" ||
      finding.sink === "insertAdjacentHTML"
    ) {
      /*console.log(
        "Generating HTML exploits for " +
          finding.location.substring(0, 80) +
          "..."
      );*/
      return htmlExploitGen;
    } else if (
      finding.sink === "eval" ||
      finding.sink === "setInterval" ||
      finding.sink === "setTimeout" ||
      finding.sink === "script.text" ||
      finding.sink === "Function.ctor"
    ) {
      /*console.log(
        "Generating JS exploits for " +
          finding.location.substring(0, 80) +
          "..."
      );*/
      return jsExploitGen;
    } else {
      return null;
    }
  }

  function isRelevantSource(func) {
    return (
      func === "location.hash" ||
      func === "location.search" ||
      func === "location.href" ||
      func === "document.documentURI" ||
      func === "document.URL" ||
      func === "document.baseURI" ||
      func === "input.value"
    );
  }

  function removeDuplicates(exploits) {
    if (exploits.methodA && exploits.methodB && exploits.methodC && exploits.methodD) {
      exploits.methodA = removeDuplicatesBy(
        (method) => method.url,
        exploits.methodA
      );
      exploits.methodB = removeDuplicatesBy(
        (method) => method.url,
        exploits.methodB
      );
      exploits.methodC = removeDuplicatesBy(
        (method) => method.url,
        exploits.methodC
      );
      exploits.methodD = removeDuplicatesBy(
        (method) => method.url,
        exploits.methodD
      );
      exploits.methodE = removeDuplicatesBy(
        (method) => method.url,
        exploits.methodE
      );
      exploits.methodF = removeDuplicatesBy(
        (method) => method.url,
        exploits.methodF
      );
      exploits.methodG = removeDuplicatesBy(
        (method) => method.url,
        exploits.methodG
      );
      exploits.methodH = removeDuplicatesBy(
        (method) => method.url,
        exploits.methodH
      );
      exploits.methodI = removeDuplicatesBy(
        (method) => method.url,
        exploits.methodI
      );
      exploits.methodJ = removeDuplicatesBy(
        (method) => method.url,
        exploits.methodJ
      );
      exploits.methodK = removeDuplicatesBy(
        (method) => method.url,
        exploits.methodK
      );
      exploits.methodM = removeDuplicatesBy(
        (method) => method.url,
        exploits.methodM
      );
      exploits.methodN = removeDuplicatesBy(
        (method) => method.url,
        exploits.methodN
      );
    }

    return exploits;
  }

  function removeDuplicatesBy(keyFn, array) {
    var mySet = new Set();
    return array.filter(function (x) {
      var key = keyFn(x);
      key = key.substring(0, key.indexOf("taintfoxLog"));
      var isNew = !mySet.has(key);
      if (isNew) mySet.add(key);
      return isNew;
    });
  }

  global.generateExploits = generateExploits;
})(exports);

("location.hash, location.search, location.href, document.documentURI, document.URL, document.baseURI, input.value");
