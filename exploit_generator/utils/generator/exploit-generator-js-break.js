(function(global) {
	'use strict';

	var statementBreak = [	"Program", "Function", "EmptyStatement", "BlockStatement", "ExpressionStatement", "IfStatement",
							"LabeledStatement", "BreakStatement", "ContinueStatement", "WithStatement", "SwitchStatement",
							"ReturnStatement", "ThrowStatement", "TryStatement", "WhileStatement", "DoWhileStatement",
							"ForStatement", "ForInStatement", "ForOfStatement",	"LetStatement",	"DebuggerStatement",
							"FunctionDeclaration", "VariableDeclaration"];

	var orBreak = ["Literal", "Identifier", "MemberExpression", "BinaryExpression", "AssignmentExpression"];

	var nodes = {	"ObjectExpression" : "}",
					"BlockStatement" : "}",
					"VariableDeclaration" : ";",
					"AssignmentExpression" : ";",
					"FunctionDeclaration" : "{};",
					"BinaryExpression" : "",
					"ExpressionStatement": "",
					"CallExpression" : ")",
					"ReturnStatement" : ";",
					"ArrayExpression" : "]",					
					"SwitchStatement" : "}",
					
	};


	// Break strategies
	function getBreakSequence(finding, parentNodesStack, node, taint, setting, regex) {
		if (!node) {
			debugger;
		}
		let result = {inBreak: "//", outBreak: ""}

		result.outBreak += closeCurrentNodeContext(node, parentNodesStack[parentNodesStack.length - 1]);
		
		for (var i = parentNodesStack.length - 1; i >= 0; i--) {
			if(nodes[parentNodesStack[i].type]) {
				result.outBreak += nodes[parentNodesStack[i].type]
			}
		}

		result.outBreak = closeOpenBrackets(finding, result.outBreak, setting, regex);
		
		if (isRelevantForOrBreak(node, taint, setting)) {
			result.outBreak += result.outBreak[result.outBreak.length - 1] !== ";" ? ";" : "";
		}
		
		if (isRelevantForStatementBreak(node, taint, setting)) {
			result.outBreak += "|";
		}

		return result;
	}

	function closeCurrentNodeContext(node, parentNode) {
		if (node.type === 'Literal' && (node.raw[0] === "\"" || node.raw[0] === "\'")) { 
			return node.raw[0];
		}
		if (node.type === 'Identifier') {
			let identifierType = "";
			for (const [key, value] of Object.entries(parentNode)) {
				if (value.type === 'Identifier' && value.range[0] === node.range[0] && value.range[1] === node.range[1]) {
					identifierType = key;
				}
			}
			return (identifierType === "params" || identifierType === "arguments") ? ")" : "";
		}
		if (node.type === 'MemberExpression') {
			for (const [key, value] of Object.entries(parentNode)) {
				if (value.type === 'Identifier' && value.range[0] === node.range[0] && value.range[1] === node.range[1]) {
					identifierType = key;
				}
			}
			return (identifierType === "test") ? ")" : "";
		}
		if (node.type === 'AssignmentExpression' || node.type === 'BinaryExpression') {
			return ";";
		}

		return "";
	}

	function closeOpenBrackets (finding, outBreak, setting, regex) {
		let preString = finding.param.substring(finding.param[0], setting.replaceBeginParam);
		let modifiedOutBreak = outBreak;

		function peek(stack) {
			return stack[stack.length - 1];
		}

		let stack = [];
		const closings = {
			'(': ')',
			'[': ']',
			'{': '}'
		}
		const openings = {
			')': '(',
			']': '[',
			'}': '{'
		}
		
		const OPENING = '([{';
		const CLOSING = ')]}';
		const QUOTES = '\'"`';

		//delete all reg ex from preString
		regex.forEach(val => {
			preString = preString.replace(unescape(val), '');
		})

		let concatenated = preString + modifiedOutBreak;

		// close brackets
		for (let i = 0; i < concatenated.length; i++) {
			let letter = concatenated.charAt(i);
			if (QUOTES.includes(letter)) {
				if (!QUOTES.includes(peek(stack))) {
					stack.push(letter);
				} else {
					if (peek(stack) === letter) {
						stack.pop();
					}
				}
			} else {
				if (!QUOTES.includes(peek(stack))) {
					if (OPENING.includes(letter)) {
						stack.push(letter);
					} else if (CLOSING.includes(letter)) {
						if (stack.length === 0) {
							if (i >= preString.length) {
								modifiedOutBreak = modifiedOutBreak.replaceAt(i - preString.length, '');
								concatenated = preString + modifiedOutBreak;
								i--;
								continue;
							} else {
								return outBreak;
							}
						} else if (peek(stack) === openings[letter]) {
							stack.pop();
						} else {
							if (i >= preString.length) {
								modifiedOutBreak = modifiedOutBreak.insert(i - preString.length, closings[peek(stack)]);
								concatenated = preString + modifiedOutBreak;
								stack.pop();
							} else {
								return outBreak;
							}
						}
					}
				}
			}
			
		}

		if (stack.length > 0) {
			// insert after the last closing bracket
			let indexLastClosingBracket = modifiedOutBreak.length - 1;
			while (indexLastClosingBracket >= 0 && !CLOSING.includes(modifiedOutBreak[indexLastClosingBracket])) {
				indexLastClosingBracket--;
			}
			for (let i = stack.length - 1; i >= 0; i--) {
				modifiedOutBreak = modifiedOutBreak.insert(indexLastClosingBracket + 1, closings[stack[i]]);
				indexLastClosingBracket++;
			}
		}

		return modifiedOutBreak;
	}

	function getBestBreakSequences(finding, nodeStack, taint, setting, regex) {
		let smallestRangeIndex = 0;
		for (var i in nodeStack) {
			if (valueIsWithinRange(setting.replaceBeginParam, nodeStack[i].range) && 
				valueIsWithinRange(setting.replaceEndParam, nodeStack[i].range) && 
				(smallestRangeIndex === 0 || (
					valueIsWithinRange(nodeStack[i].range[0], nodeStack[smallestRangeIndex].range) && 
					valueIsWithinRange(nodeStack[i].range[1], nodeStack[smallestRangeIndex].range)
				))
				&& 
				(orBreak.indexOf(nodeStack[i].type) || statementBreak.indexOf(nodeStack[i].type))) {
					smallestRangeIndex = parseInt(i)
				}
		}

		// settings.context
		setting.context.token = nodeStack[smallestRangeIndex].type;
		setting.context.content = nodeStack[smallestRangeIndex].value;


		// build parent nodes
		let parentNodesStack = nodeStack.filter((el, index) => {
			return index < smallestRangeIndex && 
			rangeIsWithinRange(nodeStack[smallestRangeIndex].range, el.range)
		});

		return getBreakSequence(finding, parentNodesStack, nodeStack[smallestRangeIndex], taint, setting, regex);
	}


	// Relevance checks

	function isRelevantForStatementBreak(node, taint, setting) {
		return statementBreak.indexOf(node.type) >= 0 && isRelevantForBreak(node, taint, setting);
	}

	function isRelevantForOrBreak(node, taint, setting) {
		return orBreak.indexOf(node.type) >= 0 && isRelevantForBreak(node, taint, setting);
	}

	function isRelevantForBreak(node, taint, setting) {
		return true;
	}

	function valueIsWithinRange(value, range) {
		return value >= range[0] && value <= range[1];
	}

	function rangeIsWithinRange(range1, range2) {
		return valueIsWithinRange(range1[0], range2) && valueIsWithinRange(range1[1], range2);
	}

	function getDefaultBreak() {
		return {"inBreak": "", "outBreak": ""};
	}

	String.prototype.replaceAt = function (index, char) {
		if(char=='') {
			return this.slice(0,index)+this.substr(index+1 + char.length);
		} else {
			return this.substr(0, index) + char + this.substr(index + char.length);
		}
	}

	String.prototype.insert = function(index, string) {
		if (index > 0)
		{
		  return this.substring(0, index) + string + this.substring(index, this.length);
		}
	  
		return string + this;
	  };

	global.getBestBreakSequences = getBestBreakSequences;
	global.getDefaultBreak = getDefaultBreak;

})(exports);